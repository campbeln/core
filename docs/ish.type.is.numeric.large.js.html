<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>ish.type.is.numeric.large.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav class="wrap">
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="ish.html">ish</a><ul class='methods'><li data-type='method'><a href="ish.html#.extend">extend</a></li><li data-type='method'><a href="ish.html#.resolve">resolve</a></li><li data-type='method'><a href="ish.html#.type!">type</a></li></ul></li><li><a href="ish.app.html">ish.app</a></li><li><a href="ish.config.html">ish.config</a><ul class='methods'><li data-type='method'><a href="ish.config.html#.!"> </a></li><li data-type='method'><a href="ish.config.html#.ish">ish</a></li><li data-type='method'><a href="ish.config.html#.require">require</a></li></ul></li><li><a href="ish.io.console.html">ish.io.console</a><ul class='methods'><li data-type='method'><a href="ish.io.console.html#.error">error</a></li><li data-type='method'><a href="ish.io.console.html#.log">log</a></li><li data-type='method'><a href="ish.io.console.html#.warn">warn</a></li></ul></li><li><a href="ish.io.event.html">ish.io.event</a><ul class='methods'><li data-type='method'><a href="ish.io.event.html#.fire">fire</a></li><li data-type='method'><a href="ish.io.event.html#.fired">fired</a></li><li data-type='method'><a href="ish.io.event.html#.registered">registered</a></li><li data-type='method'><a href="ish.io.event.html#.unregister">unregister</a></li><li data-type='method'><a href="ish.io.event.html#.unwatch">unwatch</a></li><li data-type='method'><a href="ish.io.event.html#.watch">watch</a></li></ul></li><li><a href="ish.lib.html">ish.lib</a></li><li><a href="ish.oop.html">ish.oop</a><ul class='methods'><li data-type='method'><a href="ish.oop.html#.partial">partial</a></li><li data-type='method'><a href="ish.oop.html#.protected">protected</a></li></ul></li><li><a href="ish.require.html">ish.require</a><ul class='methods'><li data-type='method'><a href="ish.require.html#.!"> </a></li><li data-type='method'><a href="ish.require.html#.css">css <client title='Client-side only'>[C]</client></a></li><li data-type='method'><a href="ish.require.html#.links">links <client title='Client-side only'>[C]</client></a></li><li data-type='method'><a href="ish.require.html#.modules">modules</a></li><li data-type='method'><a href="ish.require.html#.scripts">scripts</a></li></ul></li><li><a href="ish.type.arr.html">ish.type.arr</a><ul class='methods'><li data-type='method'><a href="ish.type.arr.html#.is">is</a></li><li data-type='method'><a href="ish.type.arr.html#.mk">mk</a></li><li data-type='method'><a href="ish.type.arr.html#.of">of</a></li><li data-type='method'><a href="ish.type.arr.html#.rm">rm</a></li></ul></li><li><a href="ish.type.bool.html">ish.type.bool</a><ul class='methods'><li data-type='method'><a href="ish.type.bool.html#.is">is</a></li><li data-type='method'><a href="ish.type.bool.html#.mk">mk</a></li></ul></li><li><a href="ish.type.date.html">ish.type.date</a><ul class='methods'><li data-type='method'><a href="ish.type.date.html#.is">is</a></li><li data-type='method'><a href="ish.type.date.html#.mk">mk</a></li><li data-type='method'><a href="ish.type.date.html#.timestamp">timestamp</a></li></ul></li><li><a href="ish.type.dom.html">ish.type.dom <client title='Client-side only'>[C]</client></a><ul class='methods'><li data-type='method'><a href="ish.type.dom.html#.is">is</a></li><li data-type='method'><a href="ish.type.dom.html#.mk">mk</a></li><li data-type='method'><a href="ish.type.dom.html#.parse">parse</a></li></ul></li><li><a href="ish.type.float.html">ish.type.float</a><ul class='methods'><li data-type='method'><a href="ish.type.float.html#.is">is</a></li><li data-type='method'><a href="ish.type.float.html#.mk">mk</a></li></ul></li><li><a href="ish.type.fn.html">ish.type.fn</a><ul class='methods'><li data-type='method'><a href="ish.type.fn.html#.call">call</a></li><li data-type='method'><a href="ish.type.fn.html#.convert">convert</a></li><li data-type='method'><a href="ish.type.fn.html#.debounce">debounce</a></li><li data-type='method'><a href="ish.type.fn.html#.is">is</a></li><li data-type='method'><a href="ish.type.fn.html#.is:arguments">is.arguments</a></li><li data-type='method'><a href="ish.type.fn.html#.mk">mk</a></li><li data-type='method'><a href="ish.type.fn.html#.noop">noop</a></li><li data-type='method'><a href="ish.type.fn.html#.once">once</a></li><li data-type='method'><a href="ish.type.fn.html#.poll">poll</a></li><li data-type='method'><a href="ish.type.fn.html#.poll:expBackoff">poll.expBackoff</a></li><li data-type='method'><a href="ish.type.fn.html#.run">run</a></li><li data-type='method'><a href="ish.type.fn.html#.throttle">throttle</a></li><li data-type='method'><a href="ish.type.fn.html#.tryCatch">tryCatch</a></li></ul></li><li><a href="ish.type.int.html">ish.type.int</a><ul class='methods'><li data-type='method'><a href="ish.type.int.html#.is">is</a></li><li data-type='method'><a href="ish.type.int.html#.mk">mk</a></li></ul></li><li><a href="ish.type.is.html">ish.type.is</a><ul class='methods'><li data-type='method'><a href="ish.type.is.html#.!"> </a></li><li data-type='method'><a href="ish.type.is.html#.collection">collection</a></li><li data-type='method'><a href="ish.type.is.html#.ish">ish</a></li><li data-type='method'><a href="ish.type.is.html#.ish:import">ish.import</a></li><li data-type='method'><a href="ish.type.is.html#.native">native</a></li><li data-type='method'><a href="ish.type.is.html#.numeric">numeric</a></li><li data-type='method'><a href="ish.type.is.html#.primitive">primitive</a></li><li data-type='method'><a href="ish.type.is.html#.value">value</a></li></ul></li><li><a href="ish.type.obj.html">ish.type.obj</a><ul class='methods'><li data-type='method'><a href="ish.type.obj.html#.get">get</a></li><li data-type='method'><a href="ish.type.obj.html#.mk">mk</a></li><li data-type='method'><a href="ish.type.obj.html#.ownKeys">ownKeys</a></li><li data-type='method'><a href="ish.type.obj.html#.rm">rm</a></li></ul></li><li><a href="ish.type.str.html">ish.type.str</a><ul class='methods'><li data-type='method'><a href="ish.type.str.html#.is">is</a></li><li data-type='method'><a href="ish.type.str.html#.is:json">is.json</a></li><li data-type='method'><a href="ish.type.str.html#.is:selector">is.selector <client title='Client-side only'>[C]</client></a></li><li data-type='method'><a href="ish.type.str.html#.mk">mk</a></li></ul></li><li><a href="ish.type.symbol.html">ish.type.symbol</a><ul class='methods'><li data-type='method'><a href="ish.type.symbol.html#.exists">exists</a></li><li data-type='method'><a href="ish.type.symbol.html#.is">is</a></li><li data-type='method'><a href="ish.type.symbol.html#.mk">mk</a></li></ul></li><li><a href="ish.ui.html">ish.ui <client title='Client-side only'>[C]</client></a><ul class='methods'><li data-type='method'><a href="ish.ui.html#.clearSelection">clearSelection</a></li><li data-type='method'><a href="ish.ui.html#.scrollTo">scrollTo</a></li></ul></li></ul><h3>Namespace Mixins</h3><ul><li><a href="ish.io.csv.html">ish.io.csv <mixin title='Mixin'>[M]</mixin></a><ul class='methods'><li data-type='method'><a href="ish.io.csv.html#.parse">parse</a></li><li data-type='method'><a href="ish.io.csv.html#.stringify">stringify</a></li></ul></li><li><a href="ish.io.xml.html">ish.io.xml <mixin title='Mixin'>[M]</mixin></a><ul class='methods'><li data-type='method'><a href="ish.io.xml.html#.parse">parse</a></li><li data-type='method'><a href="ish.io.xml.html#.stringify">stringify</a></li></ul></li><li><a href="ish.type.is.numeric.large.html">ish.type.is.numeric.large <mixin title='Mixin'>[M]</mixin></a><ul class='methods'><li data-type='method'><a href="ish.type.is.numeric.large.html#.compare">compare</a></li><li data-type='method'><a href="ish.type.is.numeric.large.html#.range">range</a></li></ul></li></ul>
    <div style="height: 30px;"></div> <!-- neek -->
</nav>

<div id="main">
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>//################################################################################################
/** @file Long Number mixin for ishJS
 * @mixin ish.type.is.numeric.large
 * @author Nick Campbell
 * @license MIT
 * @copyright 2014-2019, Nick Campbell
 */ //############################################################################################
!function () {
    'use strict';

    function init(core) {
        //################################################################################################
        /** Collection of long number functionality (range, gle and precision).
         * @namespace ish.type.is.numeric.large
         * @ignore
         */ //############################################################################################
        core.oop.partial(core.type.is, {
            numeric: {
                //#########
                /** Determines if the passed value is within the passed range.
                 * @function ish.type.is.numeric.large.range
                 * @param {string} sXML Value representing the XML data to parse.
                 * @returns {object[]} Value representing the XML data.
                 */ //#####
                //############################################################
                //# Determines if the passed sNumber is within the passed range
                //#    NOTE: "return (sNumber >= sMin &amp;&amp; sNumber &lt;= sMax)" would work in 99.9% of the checks we'll do with this function, but in the case of huge/tiny numbers (such as NUMERIC(x,y)'s in Oracle), this wouldn't cut it as the numbers would be too large/small to be represented in any available numeric variables
                //############################################################
                //# Last Updated: February 21, 2006
                range: function (sNumber, sMin, sMax) {
                    return (
                        //#### If the passed sNumber is greater then or equal to the passed sMin
                        core.type.is.numeric.cmp(sNumber, sMin) >= 0 &amp;&amp;
                        //#### If the passed sNumber is less then or equal to the passed sMax
                        core.type.is.numeric.cmp(sNumber, sMax) &lt;= 0
                    );
                }, //# type.is.numeric.large.range


                //#########
                /** Determines if the passed value is within the passed range.
                 * @function ish.type.is.numeric.large.compare
                 * @param {string} sXML Value representing the XML data to parse.
                 * @returns {object[]} Value representing the XML data.
                 */ //#####
                //############################################################
                //# Determines if the passed sNumber is greater then, less then or equal to the passed sComparedTo
                //#     Return values:
                //#          -1 if sNumber is less then sComparedTo
                //#          1 if sNumber is greater then sComparedTo
                //#          0 if the passed values are equal, or if one of the passed values was non-numeric
                //############################################################
                //# Last Updated: February 21, 2006
                compare: function (sNumber, sComparedTo) {
                    //#### Ensure the passed sNumber and sComparedTo are strings
                    sNumber += "";
                    sComparedTo += "";

                        //#### Define and init the required local vars
                    var iNumberNumericPrecision = core.type.is.numeric.precision(sNumber);
                    var iRangeNumericPrecision = core.type.is.numeric.precision(sComparedTo);
                    var iReturn;
                    var bNumberIsPositive = (sNumber.indexOf("-") !== 0);
                    var bRangeIsPositive = (sComparedTo.indexOf("-") !== 0);

                        //#### If the passed sNumber or sComparedTo were non-numeric, set our iReturn value to 0
                    if (iNumberNumericPrecision === -1 || iRangeNumericPrecision === -1) {
                        iReturn = 0;
                    }
                        //#### Else if the signs of the passed sNumber and sComparedTo do not match
                    else if (bNumberIsPositive != bRangeIsPositive) {
                            //#### If the bNumberIsPositive, then the sComparedTo is negetive, so set our iReturn value to 1 (as sNumber is greater then the sComparedTo)
                        if (bNumberIsPositive) {
                            iReturn = 1;
                        }
                            //#### Else the sNumber is negetive and the bRangeIsPositive, so set our iReturn value to -1 (as sNumber is less then the sComparedTo)
                        else {
                            iReturn = -1;
                        }
                    }
                        //#### Else the signs of the passed sNumber and sComparedTo match
                    else {
                            //#### If the above-determined .NumericPrecision's are specifying numbers of less then 1 billion
                        if (iRangeNumericPrecision &lt; 10 &amp;&amp; iNumberNumericPrecision &lt; 10) {
                                //#### Define and init the additionally required vars
                                //####     NOTE: We know that both sNumber and sComparedTo are numeric as non-numeric value are caught by .NumericPrecision above
                            var fNumber = parseFloat(sNumber);
                            var fRange = parseFloat(sComparedTo);

                                //#### If the sNumber and sComparedTo are equal, set our iReturn value to 0
                            if (fNumber == fRange) {
                                iReturn = 0;
                            }
                                //#### Else if the sNumber is greater then the sComparedTo, set our iReturn value to 1
                            else if (fNumber > fRange) {
                                iReturn = 1;
                            }
                                //#### Else the fNumber is less then the sComparedTo, so set our iReturn value to -1
                            else {
                                iReturn = -1;
                            }
                        }
                            //#### Else we're dealing with number ranges over 1 billion, so let's get creative...
                        else {
                                //#### If the iNumber('s)NumericPrecision is less then the iRange('s)NumericPrecision
                            if (iNumberNumericPrecision &lt; iRangeNumericPrecision) {
                                    //#### If the bNumberIsPositive (and thanks to the check above the bRangeIs(also)Positive), return -1 (as the sNumber is a smaller positive number then the sComparedTo, making it less)
                                if (bNumberIsPositive) {
                                    iReturn = -1;
                                }
                                    //#### Else the bNumberIs(not)Positive (and thanks to the check above the bRangeIs(also not)Positive), so return 1 (as the sNumber is a smaller negetive number then the sComparedTo, making it greater)
                                else {
                                    iReturn = 1;
                                }
                            }
                                //#### Else if the iNumber('s)NumericPrecision is more then the iRange('s)NumericPrecision
                            else if (iNumberNumericPrecision > iRangeNumericPrecision) {
                                    //#### If the bNumberIsPositive (and thanks to the check above the bRangeIs(also)Positive), return 1 (as the sNumber is a bigger positive number then the sComparedTo, making it greater)
                                if (bNumberIsPositive) {
                                    iReturn = 1;
                                }
                                    //#### Else the bNumberIs(not)Positive (and thanks to the check above the bRangeIs(also not)Positive), so return -1 (as the sNumber is a bigger negetive number then the sComparedTo, making it less)
                                else {
                                    iReturn = -1;
                                }
                            }
                                //#### Else the iNumber('s)NumericPrecision is equal to the iRange('s)NumericPrecision, so additional checking is required
                            else {
                                    //#### Define and set the additionally required decimal point position variables
                                var iNumberDecimalPoint = sNumber.indexOf(".");
                                var iRangeDecimalPoint = sComparedTo.indexOf(".");

                                    //#### If either/both of the decimal points were not found above, reset iNumberDecimalPoint/iRangeDecimalPoint to their respective .lengths (which logicially places the iRangeDecimalPoint at the end of the sCurrentRange, which is where it is located)
                                    //####    NOTE: Since this function only checks that the passed sNumber is within the passed range, the values "whole" -vs- "floating point" number distinction is ignored as for our purposes, it is unimportant.
                                if (iNumberDecimalPoint == -1) {
                                    iNumberDecimalPoint = sNumber.length;
                                }
                                if (iRangeDecimalPoint == -1) {
                                    iRangeDecimalPoint = sComparedTo.length;
                                }

                                    //#### If the sNumber's decimal point is to the left of sComparedTo's (making sNumber less then sComparedTo), set our iReturn value to -1
                                if (iNumberDecimalPoint &lt; iRangeDecimalPoint) {
                                    iReturn = -1;
                                }
                                    //#### Else if the sNumber's decimal point is to the right of sComparedTo's (making sNumber greater then sComparedTo), set our iReturn value to 1
                                else if (iNumberDecimalPoint > iRangeDecimalPoint) {
                                    iReturn = 1;
                                }
                                    //#### Else the sNumber's decimal point is in the same position as the sComparedTo's decimal point
                                else {
                                        //#### Define and init the additionally required vars
                                    var iCurrentNumberNumber;
                                    var iCurrentRangeNumber;
                                    var i;

                                        //#### Default our iReturn value to 0 (as only > and &lt; are checked in the loop below, so if the loop finishes without changing the iReturn value then the sNumber and sComparedTo are equal)
                                    iReturn = 0;

                                        //#### Setup the value for i based on if the bNumberIsPositive (setting it to 0 if it is, or 1 if it isn't)
                                        //####    NOTE: This is done to skip over the leading "-" sign in negetive numbers (yea it's ugly, but it works!)
                                        //####    NOTE: Since at this point we know that signs of sNumber and sComparedTo match, we only need to check bNumberIsPositive's value
                                    i = (bNumberIsPositive) ? (0) : (1);

                                        //#### Traverse the sNumber/sComparedTo strings from front to back (based on the above determined starting position)
                                        //####     NOTE: Since everything is is the same position and the same precision, we know that sNumber's .lenght is equal to sComparedTo's
                                    for (i; i &lt; sNumber.length; i++) {
                                            //#### As long as we're not looking at the decimal point
                                        if (i != iNumberDecimalPoint) {
                                                //#### Determine the iCurrentNumberNumber and iCurrentRangeNumber for this loop
                                            iCurrentNumberNumber = parseInt(sNumber[i]);
                                            iCurrentRangeNumber = parseInt(sComparedTo[i]);

                                                //#### If the iCurrentNumberNumber is less then the iCurrentRangeNumber
                                            if (iCurrentNumberNumber &lt; iCurrentRangeNumber) {
                                                    //#### sNumber is less then sComparedTo, so set our iReturn value to -1 and fall from the loop
                                                iReturn = -1;
                                                break;
                                            }
                                                //#### Else if the iCurrentNumberNumber is greater then the iCurrentRangeNumber
                                            if (iCurrentNumberNumber > iCurrentRangeNumber) {
                                                    //#### sNumber is greater then sComparedTo, so set our iReturn value to 1 and fall from the loop
                                                iReturn = 1;
                                                break;
                                            }
                                        }
                                    } //# for
                                }
                            }
                        }
                    }

                        //#### Return the above determined iReturn value to the caller
                    return iReturn;
                }, //# ish.type.is.numeric.large.compare

                //############################################################
                //# Determines the numeric precision of the passed sValue (i.e. - counts how many numeric places there are within the number, not including leading 0's)
                //############################################################
                //# Last Updated: April 19, 2006
                precision: function (vValue) {
                    var sCurrentChar, i, bStartCounting,
                        sValue = core.type.str.mk(vValue).trim(),
                        iReturnVal = (/^(-)?[0-9.,]{1,}$/.test(sValue) ? 0 : -1)
                    ;

                    //# If the sValue holds only numeric characters
                    if (iReturnVal === 0) {
                        //#### Traverse the .length of the passed sValue, collecting the sCurrentChar as we go
                        for (i = 0; i &lt; sValue.length; i++) {
                            sCurrentChar = sValue[i]; //# .substr(i, 1)

                            //#### If the sCurrentChar is.numeric
                            if (core.type.is.numeric(sCurrentChar)) {
                                //#### If we are supposed to bStartCounting, inc our iReturnVal
                                //####    NOTE: This is done so we ignore leading 0's (trailing 0's are still counted)
                                bStartCounting = (sCurrentChar !== '0');
                                iReturnVal += (bStartCounting ? 1 : 0);
                            }
                        }
                    }

                    return iReturnVal;
                } //# ish.type.is.numeric.large.precision
            }
        }); //# core.type.num
    } //# init


    //# If we are running server-side
    //#     NOTE: Does not work with strict CommonJS, but only CommonJS-like environments that support module.exports, like Node.
    if (typeof module === 'object' &amp;&amp; module.exports) { //if (typeof module !== 'undefined' &amp;&amp; this.module !== module &amp;&amp; module.exports) {
        module.exports = init;
    }
    //# Else if we are running in an .amd environment, register as an anonymous module
    else if (typeof define === 'function' &amp;&amp; define.amd) {
        define([], init);
    }
    //# Else we are running in the browser, so we need to setup the _document-based features
    else {
        init(document.querySelector("SCRIPT[ish]").ish);
    }
}();
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sat, 12 Oct 2019 07:02:32 GMT using the <a href="https://github.com/clenemt/docdash">docdash</a> theme and tested with <a href="https://www.chaijs.com/api/assert/">Chai.Assert</a>.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>



</body>
</html>
